/**
  * Created by Artsiom Amialchuk on 29.05.2016.
  */
class Maze {

  /*
  rando_Maze_r
   */
  val random = scala.util.Random

  /*
  dimension of hypercube
   */
  def n = 2

  /**
    * Size: n x n x n x n
    * Volume: n^4 cells
    * First and last cells are free (0)
    * All other cells are generated by random
    */
  def hyperCube = {
    for (i <- 0 until n) yield
      for (j <- 0 until n) yield
        for (k <- 0 until n) yield
          for (l <- 0 until n) yield if (i == j && k == l && i == l) {
            0
          } else {
            random.nextInt(2)
          }
  }

  var counter = 0

  def checkMaze(i: Int, j: Int, k: Int, l: Int, path: List[(Int, Int, Int, Int)]) : Any = {
    if (i == n - 1 && j == n - 1 && k == n - 1 && l == n - 1) {
      counter += 1
    }
    else {
      if (i > 0 && hyperCube(i - 1)(j)(k)(l) == 0 && !path.contains((i-1, j, k, l))) checkMaze(i - 1, j, k, l,  path :+(i-1, j, k, l))
      if (i < n - 1 && hyperCube(i + 1)(j)(k)(l) == 0 && !path.contains((i+1, j, k, l))) checkMaze(i + 1, j, k, l,  path :+(i+1, j, k, l))
      if (j > 0 && hyperCube(i)(j - 1)(k)(l) == 0 && !path.contains((i, j-1, k, l))) checkMaze(i, j - 1, k, l,  path :+(i, j-1, k, l))
      if (j < n - 1 && hyperCube(i)(j + 1)(k)(l) == 0 && !path.contains((i, j+1, k, l))) checkMaze(i, j + 1, k, l,  path :+(i, j+1, k, l))
      if (k > 0 && hyperCube(i)(j)(k - 1)(l) == 0 && !path.contains((i, j, k-1, l))) checkMaze(i, j, k - 1, l,  path :+(i, j, k-1, l))
      if (k < n - 1 && hyperCube(i)(j)(k + 1)(l) == 0 && !path.contains((i, j, k+1, l))) checkMaze(i, j, k + 1, l,  path :+(i, j, k+1, l))
      if (l > 0 && hyperCube(i)(j)(k)(l - 1) == 0 && !path.contains((i, j, k, l-1))) checkMaze(i, j, k, l - 1,  path :+(i, j, k, l-1))
      if (l < n - 1 && hyperCube(i)(j)(k)(l + 1) == 0 && !path.contains((i, j, k, l+1))) checkMaze(i, j, k, l + 1,  path :+(i, j, k, l+1))
    }
  }

  checkMaze(0, 0, 0, 0, List((0,0,0,0)))
  print("Labyrinth is possible to pass in " +  counter +  " ways.")
}

